{% if !type_imports.is_empty() %}import type { {% for type_import in type_imports %}{{ type_import }}{% if !loop.last %}, {% endif %}{% endfor %} } from '../types';
{% endif %}import { UnexpectedError } from '../types/errors';
{% if !auth_schemes.is_empty() %}import { SecurityConfig } from './client';{% endif %}

// Operation-specific error classes
{% for operation in operations %}{% for error in operation.error_variants %}
/**
 * Error thrown when {{ operation.method_name }} returns status {{ error.status_code }}.
 */
export class {{ error.class_name }} extends globalThis.Error {
  readonly status = {{ error.status_code }};
{% if error.has_body %}  readonly body: {{ error.body_type }};

  constructor(body: {{ error.body_type }}) {
    super(`{{ error.class_name }}`);
    this.name = '{{ error.class_name }}';
    this.body = body;
  }
{% else %}
  constructor() {
    super(`{{ error.class_name }}`);
    this.name = '{{ error.class_name }}';
  }
{% endif %}}
{% endfor %}{% endfor %}
{% if let Some(summary) = docs.summary %}/**
 * {{ summary }}
{% if let Some(description) = docs.description %} *
 * {{ description }}
{% endif %} */
{% endif %}export class {{ name.pascal }}Service {
  constructor(private baseUrl: string, {% if !auth_schemes.is_empty() %}private security: SecurityConfig{% endif %}) {}

{% for operation in operations %}  {% if let Some(summary) = operation.docs.summary %}/**
   * {{ summary }}
{% if let Some(description) = operation.docs.description %}   *
   * {{ description }}
{% endif %}{% if !operation.params.is_empty() %}   *
{% for param in operation.params %}   * @param {{ param.name }} {% if let Some(doc) = param.docs %}{{ doc }}{% endif %}
{% endfor %}{% endif %}{% if operation.has_errors %}   * @throws {{ "{" }}{% for error in operation.error_variants %}{{ error.class_name }}{% if !loop.last %} | {% endif %}{% endfor %} | UnexpectedError{{ "}" }}
{% endif %}   */
  {% endif %}async {{ operation.method_name }}({% if operation.has_params %}params: {
{% for param in operation.params %}    {{ param.name }}{% if param.optional %}?{% endif %}: {{ param.type_str }};
{% endfor %}  }{% endif %}): Promise<{{ operation.return_type }}> {
    {% if !operation.path_params.is_empty() %}const path = `{{ operation.path_template }}`{% for path_param in operation.path_params %}.replace('{{ path_param.placeholder }}', String(params.{{ path_param.name }})){% endfor %};
    {% else %}const path = '{{ operation.path_template }}';
    {% endif %}{% if !operation.query_params.is_empty() %}const queryParams = new URLSearchParams();
{% for query_param in operation.query_params %}    if (params.{{ query_param.name }} !== undefined) {
      queryParams.append('{{ query_param.wire }}', String(params.{{ query_param.name }}));
    }
{% endfor %}    const queryString = queryParams.toString();
    const url = queryString ? `${this.baseUrl}${path}?${queryString}` : `${this.baseUrl}${path}`;
    {% else %}const url = `${this.baseUrl}${path}`;
    {% endif %}
    {% if operation.has_body || !operation.header_params.is_empty() || !operation.auth_schemes.is_empty() %}const headers: Record<string, string> = {};
    {% if operation.has_body %}headers['Content-Type'] = 'application/json';
    {% endif %}{% for header_param in operation.header_params %}headers['{{ header_param.wire }}'] = String(params.{{ header_param.name }});
    {% endfor %}{% for auth in operation.auth_schemes %}{% if auth.kind == "bearer_bearer" %}if (this.security.{{ auth.name_camel }}) {
      headers['Authorization'] = `Bearer ${this.security.{{ auth.name_camel }}}`;
    }
    {% endif %}{% if auth.kind == "apikey_header" %}{% if let Some(param) = auth.param_name %}if (this.security.{{ auth.name_camel }}) {
      headers['{{ param }}'] = this.security.{{ auth.name_camel }};
    }
    {% endif %}{% endif %}{% endfor %}
    {% endif %}const response = await fetch(url, {
      method: '{{ operation.http_method }}',{% if operation.has_body || !operation.header_params.is_empty() || !operation.auth_schemes.is_empty() %}
      headers,{% endif %}{% if operation.has_body %}
      body: JSON.stringify(params.body),{% endif %}
    });

    if (!response.ok) {
{% if operation.has_errors %}      switch (response.status) {
{% for error in operation.error_variants %}        case {{ error.status_code }}: {
{% if error.has_body %}          try {
            const body = await response.json() as {{ error.body_type }};
            throw new {{ error.class_name }}(body);
          } catch (e) {
            if (e instanceof {{ error.class_name }}) throw e;
            throw new UnexpectedError(response.status, await response.text());
          }
{% else %}          throw new {{ error.class_name }}();
{% endif %}        }
{% endfor %}        default:
          throw new UnexpectedError(response.status, await response.text());
      }
{% else %}      throw new UnexpectedError(response.status, await response.text());
{% endif %}    }

    {% if operation.has_return %}return response.json();{% else %}return;{% endif %}
  }

{% endfor %}}
