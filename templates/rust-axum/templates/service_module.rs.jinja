//! {{ trait_name }} service module
use axum::{
    http::{header, StatusCode},
    response::{IntoResponse, Response},
    routing::{
        {%- for method in methods %}{{ method }}{% if !loop.last %}, {% endif %}{% endfor -%}
    },
    Extension, Json, Router,
};

use crate::shared::RequestContext;

{% if has_bearer_auth -%}
/// Bearer authentication token
#[derive(Clone, Debug)]
pub struct AuthBearer(pub String);

{% endif -%}
{% if has_api_key_auth -%}
/// API Key authentication
#[derive(Clone, Debug)]
pub struct AuthApiKey(pub String);

{% endif -%}

// Per-operation result and error types
{% for op_wrap in operations -%}
{% set op = op_wrap.operation -%}

// {{ op.name.pascal }} types
{% match op_wrap.response_content_type -%}
{% when ResponseContentType::MultipleBinary -%}
/// Binary response with multiple supported content types.
/// Use the appropriate variant to set the Content-Type header.
#[derive(Debug)]
pub enum {{ op.name.pascal }}Response {
    {% for ct in op_wrap.binary_content_types -%}
    {% let variant_name = ct.replace("/", "_").replace("-", "_").replace("+", "_").replace(".", "_") -%}
    /// Response with Content-Type: {{ ct }}
    {{ variant_name|to_pascal_case }}(bytes::Bytes),
    {% endfor -%}
    /// Custom content type response
    Custom { content_type: String, body: bytes::Bytes },
}

impl IntoResponse for {{ op.name.pascal }}Response {
    fn into_response(self) -> Response {
        match self {
            {% for ct in op_wrap.binary_content_types -%}
            {% let variant_name = ct.replace("/", "_").replace("-", "_").replace("+", "_").replace(".", "_") -%}
            {{ op.name.pascal }}Response::{{ variant_name|to_pascal_case }}(body) => {
                ([(header::CONTENT_TYPE, "{{ ct }}")], body).into_response()
            }
            {% endfor -%}
            {{ op.name.pascal }}Response::Custom { content_type, body } => {
                ([(header::CONTENT_TYPE, content_type)], body).into_response()
            }
        }
    }
}

pub type {{ op.name.pascal }}Result = Result<{{ op.name.pascal }}Response, {{ op.name.pascal }}Error>;
{% when ResponseContentType::Binary -%}
{% if let Some(success) = op.success -%}
{% if let Some(ty) = success.ty -%}
/// Binary response wrapper that sets the Content-Type header.
#[derive(Debug)]
pub struct {{ op.name.pascal }}Response(pub {{ ty.target|render_type }});

impl IntoResponse for {{ op.name.pascal }}Response {
    fn into_response(self) -> Response {
        {% if let Some(ct) = success.content_type -%}
        ([(header::CONTENT_TYPE, "{{ ct }}")], self.0).into_response()
        {% else -%}
        ([(header::CONTENT_TYPE, "application/octet-stream")], self.0).into_response()
        {% endif -%}
    }
}

pub type {{ op.name.pascal }}Result = Result<{{ op.name.pascal }}Response, {{ op.name.pascal }}Error>;
{% else -%}
pub type {{ op.name.pascal }}Result = Result<(), {{ op.name.pascal }}Error>;
{% endif -%}
{% else -%}
pub type {{ op.name.pascal }}Result = Result<(), {{ op.name.pascal }}Error>;
{% endif -%}
{% when _ -%}
{% if let Some(success) = op.success -%}
{% if let Some(ty) = success.ty -%}
pub type {{ op.name.pascal }}Result = Result<{{ ty.target|render_type }}, {{ op.name.pascal }}Error>;
{% else -%}
pub type {{ op.name.pascal }}Result = Result<(), {{ op.name.pascal }}Error>;
{% endif -%}
{% else -%}
pub type {{ op.name.pascal }}Result = Result<(), {{ op.name.pascal }}Error>;
{% endif -%}
{% endmatch -%}

#[derive(Debug)]
pub enum {{ op.name.pascal }}Error {
    {% match op.errors -%}
    {% when ir::gen_ir::ErrorUse::Inline with (error_decl) -%}
    {% for variant in error_decl.variants -%}
    /// Status: {{ variant.status|fmt("{:?}") }}
    {{ variant.name.pascal }}{% if let Some(ty) = variant.ty %}({{ ty.target|render_type }}){% endif %},
    {% endfor -%}
    {% when _ -%}
    InternalError(String),
    {% endmatch -%}
}

impl IntoResponse for {{ op.name.pascal }}Error {
    fn into_response(self) -> Response {
        match self {
            {% match op.errors -%}
            {% when ir::gen_ir::ErrorUse::Inline with (error_decl) -%}
            {% for variant in error_decl.variants -%}
            {{ op.name.pascal }}Error::{{ variant.name.pascal }}{% if variant.ty.is_some() %}(err){% endif %} => {
                {% match variant.status -%}
                {% when ir::gen_ir::StatusSpec::Code with (code) -%}
                let status = {{ code|status_code_const }};
                {% when _ -%}
                let status = StatusCode::BAD_REQUEST;
                {% endmatch -%}
                {% if variant.ty.is_some() -%}
                (status, Json(err)).into_response()
                {% else -%}
                status.into_response()
                {% endif -%}
            }
            {% endfor -%}
            {% when _ -%}
            {{ op.name.pascal }}Error::InternalError(msg) => {
                (StatusCode::INTERNAL_SERVER_ERROR, msg).into_response()
            }
            {% endmatch -%}
        }
    }
}

{% endfor %}

// Multipart request structs
{% for op_wrap in operations -%}
{% set op = op_wrap.operation -%}
{% match op_wrap.request_content_type -%}
{% when RequestContentType::Multipart -%}
{% if let Some(body) = op.http.body -%}
{% if let Some(variant) = body.variants.first() -%}

// {{ op.name.pascal }} multipart request
#[derive(Debug)]
pub struct {{ op.name.pascal }}Request {
    {%- for encoding in variant.encoding %}
    pub {{ encoding.field.snake|escape_rust_keyword }}: {% match encoding.ty.target -%}
    {%- when ir::gen_ir::StableId::Primitive with (p) -%}
    {%- match p -%}
    {%- when ir::gen_ir::Primitive::Bytes -%}
    crate::multipart::Spooled
    {%- when _ -%}
    {{ encoding.ty.target|render_type }}
    {%- endmatch -%}
    {%- when _ -%}
    {{ encoding.ty.target|render_type }}
    {%- endmatch %},
    {%- endfor %}
}

#[derive(Debug)]
pub struct {{ op.name.pascal }}Rejection {
    message: String,
    status: StatusCode,
}

impl {{ op.name.pascal }}Rejection {
    fn bad_request(message: impl Into<String>) -> Self {
        Self {
            message: message.into(),
            status: StatusCode::BAD_REQUEST,
        }
    }

    fn payload_too_large(message: impl Into<String>) -> Self {
        Self {
            message: message.into(),
            status: StatusCode::PAYLOAD_TOO_LARGE,
        }
    }

    fn internal_error(message: impl Into<String>) -> Self {
        Self {
            message: message.into(),
            status: StatusCode::INTERNAL_SERVER_ERROR,
        }
    }
}

impl IntoResponse for {{ op.name.pascal }}Rejection {
    fn into_response(self) -> Response {
        (self.status, self.message).into_response()
    }
}

impl<S> axum::extract::FromRequest<S> for {{ op.name.pascal }}Request
where
    S: Send + Sync,
{
    type Rejection = {{ op.name.pascal }}Rejection;

    fn from_request(
        req: axum::http::Request<axum::body::Body>,
        state: &S,
    ) -> impl std::future::Future<Output = Result<Self, Self::Rejection>> + Send {
        async move {
            // Delegate to axum's Multipart extractor
            let multipart = axum::extract::Multipart::from_request(req, state)
                .await
                .map_err(|e| {{ op.name.pascal }}Rejection::bad_request(format!("multipart error: {}", e)))?;

            Self::decode_multipart(multipart).await
        }
    }
}

impl {{ op.name.pascal }}Request {
    async fn decode_multipart(mut multipart: axum::extract::Multipart) -> Result<Self, {{ op.name.pascal }}Rejection> {
        {%- for encoding in variant.encoding %}
        let mut {{ encoding.field.snake|escape_rust_keyword }}: Option<_> = None;
        {%- endfor %}

        while let Some(field) = multipart.next_field()
            .await
            .map_err(|e| {{ op.name.pascal }}Rejection::bad_request(format!("multipart field error: {}", e)))?
        {
            let name = field.name().map(str::to_owned).unwrap_or_default();

            match name.as_str() {
                {%- for encoding in variant.encoding %}
                "{{ encoding.field.canonical }}" => {
                    if {{ encoding.field.snake|escape_rust_keyword }}.is_some() {
                        return Err({{ op.name.pascal }}Rejection::bad_request(format!("duplicate field: {}", "{{ encoding.field.canonical }}")));
                    }
                    {% match encoding.ty.target -%}
                    {%- when ir::gen_ir::StableId::Primitive with (p) -%}
                    {%- match p -%}
                    {%- when ir::gen_ir::Primitive::Bytes -%}
                    let spooled = crate::multipart::spool_multipart_field(
                        field,
                        crate::multipart::DEFAULT_SPILL_THRESHOLD,
                        None,
                    )
                    .await
                    .map_err(|e| match e {
                        crate::multipart::UploadParseError::FieldTooLarge { field_name, limit_bytes, observed_bytes } => {
                            {{ op.name.pascal }}Rejection::payload_too_large(
                                format!("field '{}' too large: {} > {} bytes", field_name, observed_bytes, limit_bytes)
                            )
                        }
                        crate::multipart::UploadParseError::Io(e) => {
                            {{ op.name.pascal }}Rejection::internal_error(format!("io error: {}", e))
                        }
                        e => {{ op.name.pascal }}Rejection::bad_request(format!("upload error: {}", e)),
                    })?;
                    {{ encoding.field.snake|escape_rust_keyword }} = Some(spooled);
                    {%- when ir::gen_ir::Primitive::String -%}
                    let text = field
                        .text()
                        .await
                        .map_err(|_| {{ op.name.pascal }}Rejection::bad_request(format!("invalid utf-8 in field: {}", name)))?;
                    {{ encoding.field.snake|escape_rust_keyword }} = Some(text);
                    {%- when ir::gen_ir::Primitive::Bool -%}
                    let text = field
                        .text()
                        .await
                        .map_err(|_| {{ op.name.pascal }}Rejection::bad_request(format!("invalid utf-8 in field: {}", name)))?;
                    let parsed = text.parse::<bool>()
                        .map_err(|e| {{ op.name.pascal }}Rejection::bad_request(format!("invalid boolean in field '{}': {}", name, e)))?;
                    {{ encoding.field.snake|escape_rust_keyword }} = Some(parsed);
                    {%- when ir::gen_ir::Primitive::I32 -%}
                    let text = field
                        .text()
                        .await
                        .map_err(|_| {{ op.name.pascal }}Rejection::bad_request(format!("invalid utf-8 in field: {}", name)))?;
                    let parsed = text.parse::<i32>()
                        .map_err(|e| {{ op.name.pascal }}Rejection::bad_request(format!("invalid i32 in field '{}': {}", name, e)))?;
                    {{ encoding.field.snake|escape_rust_keyword }} = Some(parsed);
                    {%- when ir::gen_ir::Primitive::I64 -%}
                    let text = field
                        .text()
                        .await
                        .map_err(|_| {{ op.name.pascal }}Rejection::bad_request(format!("invalid utf-8 in field: {}", name)))?;
                    let parsed = text.parse::<i64>()
                        .map_err(|e| {{ op.name.pascal }}Rejection::bad_request(format!("invalid i64 in field '{}': {}", name, e)))?;
                    {{ encoding.field.snake|escape_rust_keyword }} = Some(parsed);
                    {%- when ir::gen_ir::Primitive::F32 -%}
                    let text = field
                        .text()
                        .await
                        .map_err(|_| {{ op.name.pascal }}Rejection::bad_request(format!("invalid utf-8 in field: {}", name)))?;
                    let parsed = text.parse::<f32>()
                        .map_err(|e| {{ op.name.pascal }}Rejection::bad_request(format!("invalid f32 in field '{}': {}", name, e)))?;
                    {{ encoding.field.snake|escape_rust_keyword }} = Some(parsed);
                    {%- when ir::gen_ir::Primitive::F64 -%}
                    let text = field
                        .text()
                        .await
                        .map_err(|_| {{ op.name.pascal }}Rejection::bad_request(format!("invalid utf-8 in field: {}", name)))?;
                    let parsed = text.parse::<f64>()
                        .map_err(|e| {{ op.name.pascal }}Rejection::bad_request(format!("invalid f64 in field '{}': {}", name, e)))?;
                    {{ encoding.field.snake|escape_rust_keyword }} = Some(parsed);
                    {%- when ir::gen_ir::Primitive::Date -%}
                    let text = field
                        .text()
                        .await
                        .map_err(|_| {{ op.name.pascal }}Rejection::bad_request(format!("invalid utf-8 in field: {}", name)))?;
                    let parsed = text.parse::<jiff::civil::Date>()
                        .map_err(|e| {{ op.name.pascal }}Rejection::bad_request(format!("invalid date in field '{}': {}", name, e)))?;
                    {{ encoding.field.snake|escape_rust_keyword }} = Some(parsed);
                    {%- when ir::gen_ir::Primitive::DateTime -%}
                    let text = field
                        .text()
                        .await
                        .map_err(|_| {{ op.name.pascal }}Rejection::bad_request(format!("invalid utf-8 in field: {}", name)))?;
                    let parsed = text.parse::<jiff::Timestamp>()
                        .map_err(|e| {{ op.name.pascal }}Rejection::bad_request(format!("invalid datetime in field '{}': {}", name, e)))?;
                    {{ encoding.field.snake|escape_rust_keyword }} = Some(parsed);
                    {%- when ir::gen_ir::Primitive::Uuid -%}
                    let text = field
                        .text()
                        .await
                        .map_err(|_| {{ op.name.pascal }}Rejection::bad_request(format!("invalid utf-8 in field: {}", name)))?;
                    let parsed = text.parse::<uuid::Uuid>()
                        .map_err(|e| {{ op.name.pascal }}Rejection::bad_request(format!("invalid UUID in field '{}': {}", name, e)))?;
                    {{ encoding.field.snake|escape_rust_keyword }} = Some(parsed);
                    {%- when ir::gen_ir::Primitive::Decimal -%}
                    let text = field
                        .text()
                        .await
                        .map_err(|_| {{ op.name.pascal }}Rejection::bad_request(format!("invalid utf-8 in field: {}", name)))?;
                    let parsed = text.parse::<rust_decimal::Decimal>()
                        .map_err(|e| {{ op.name.pascal }}Rejection::bad_request(format!("invalid decimal in field '{}': {}", name, e)))?;
                    {{ encoding.field.snake|escape_rust_keyword }} = Some(parsed);
                    {%- when ir::gen_ir::Primitive::Any -%}
                    let text = field
                        .text()
                        .await
                        .map_err(|_| {{ op.name.pascal }}Rejection::bad_request(format!("invalid utf-8 in field: {}", name)))?;
                    let parsed = serde_json::from_str::<serde_json::Value>(&text)
                        .map_err(|e| {{ op.name.pascal }}Rejection::bad_request(format!("invalid JSON in field '{}': {}", name, e)))?;
                    {{ encoding.field.snake|escape_rust_keyword }} = Some(parsed);
                    {%- endmatch -%}
                    {%- when ir::gen_ir::StableId::Named with (_) -%}
                    let text = field
                        .text()
                        .await
                        .map_err(|_| {{ op.name.pascal }}Rejection::bad_request(format!("invalid utf-8 in field: {}", name)))?;
                    let parsed = serde_json::from_str(&text)
                        .map_err(|e| {{ op.name.pascal }}Rejection::bad_request(format!("invalid JSON in field '{}': {}", name, e)))?;
                    {{ encoding.field.snake|escape_rust_keyword }} = Some(parsed);
                    {%- endmatch -%}
                }
                {%- endfor %}
                other => {
                    return Err({{ op.name.pascal }}Rejection::bad_request(format!("unexpected field: {}", other)));
                }
            }
        }

        Ok(Self {
            {%- for encoding in variant.encoding %}
            {{ encoding.field.snake|escape_rust_keyword }}: {{ encoding.field.snake|escape_rust_keyword }}
                .ok_or_else(|| {{ op.name.pascal }}Rejection::bad_request(format!("missing field: {}", "{{ encoding.field.canonical }}")))?,
            {%- endfor %}
        })
    }
}

{% endif -%}
{% endif -%}
{% when _ -%}
{% endmatch -%}
{% endfor %}

/// {{ trait_name }} service trait
///
/// # Example
///
/// ```rust
/// use {{ package_name }}::shared::RequestContext;
/// use {{ package_name }}::services::{{ module_name }}::{
///     {{ trait_name }},
{% for op_wrap in operations -%}
{% set op = op_wrap.operation -%}
///     {{ op.name.pascal }}Result,
{% if op.http.query.len() > 0 -%}
///     {{ op.name.pascal }}Query,
{% endif -%}
{% endfor -%}
/// };
///
/// // Define your application state
/// #[derive(Clone)]
/// struct AppState {
///     // Add your state fields here (e.g., database connection, config, etc.)
/// }
///
/// // Define your service implementation
/// #[derive(Clone)]
/// struct {{ trait_name }}Service {
///     // Add any dependencies your service needs
/// }
///
/// impl {{ trait_name }}Service {
///     fn new() -> Self {
///         Self {}
///     }
/// }
///
/// // Implement the trait
/// impl {{ trait_name }}<AppState> for {{ trait_name }}Service {
{% for op_wrap in operations -%}
{% set op = op_wrap.operation -%}
///     async fn {{ op.name.snake }}(
///         &self,
///         ctx: RequestContext<AppState>,
{% for param in op.http.path_params -%}
///         {{ param.name.snake|escape_rust_keyword }}: String,
{% endfor -%}
{% if op.http.query.len() > 0 -%}
///         query: {{ op.name.pascal }}Query,
{% endif -%}
{% if let Some(body) = op.http.body -%}
{% if let Some(variant) = body.variants.first() -%}
///         body: {{ package_name }}::types::{{ variant.ty.target }},
{% endif -%}
{% endif -%}
///     ) -> {{ op.name.pascal }}Result {
///         // Implement your business logic here
{% if let Some(success) = op.success -%}
{% if let Some(ty) = success.ty -%}
///         // Return Ok(your_{{ ty.target|lower }}) or Err(error)
///         todo!("implement {{ op.name.snake }}")
{% else -%}
///         Ok(())
{% endif -%}
{% else -%}
///         Ok(())
{% endif -%}
///     }
///
{% endfor -%}
/// }
///
/// // Usage: Create router and merge into your app
/// # async fn example() {
/// let state = AppState {};
/// let service = {{ trait_name }}Service::new();
///
/// let app = axum::Router::new()
///     .with_state(state)
///     .merge(service.router());
/// # }
/// ```
pub trait {{ trait_name }}<S>: Send + Sync + Clone + Sized + 'static
where
    S: Clone + Send + Sync + 'static,
{
    {% for op_wrap in operations -%}
    {% set op = op_wrap.operation -%}
    /// {{ op.http.method|fmt("{:?}") }} {{ op.http.path_template }}
    fn {{ op.name.snake }}(
        &self,
        ctx: RequestContext<S>,
        {% for param in op.http.path_params -%}
        {{ param.name.snake|escape_rust_keyword }}: String,
        {% endfor -%}
        {% if op.http.query .len() > 0 -%}
        query: {{ op.name.pascal }}Query,
        {% endif -%}
        {% match op_wrap.request_content_type -%}
        {% when RequestContentType::Multipart -%}
        body: {{ op.name.pascal }}Request,
        {% when RequestContentType::OctetStream -%}
        body: bytes::Bytes,
        {% when RequestContentType::Json -%}
        {% if let Some(body) = op.http.body -%}
        {% if let Some(variant) = body.variants.first() -%}
        body: {{ variant.ty.target|render_type }},
        {% endif -%}
        {% endif -%}
        {% when RequestContentType::None -%}
        {% endmatch -%}
    ) -> impl std::future::Future<Output = {{ op.name.pascal }}Result> + Send;

    {% endfor -%}

    /// Create a router for this service
    fn router(self) -> Router<S> {
        {% for op_wrap in operations -%}
        {% set op = op_wrap.operation -%}
        let {{ op.name.snake }}_handler = |ctx: RequestContext<S>, Extension(service): Extension<Self>{% if op.http.path_params .len() == 1 %}, axum::extract::Path(path_params): axum::extract::Path<String>{% else if op.http.path_params .len() > 1 %}, axum::extract::Path(path_params): axum::extract::Path<({% for p in op.http.path_params -%}
            String{% if !loop.last %}, {% endif -%}
        {% endfor %})>{% endif -%}
        {% if op.http.query .len() > 0 %}, axum::extract::Query(query): axum::extract::Query<{{ op.name.pascal }}Query>{% endif -%}
        {% match op_wrap.request_content_type -%}
        {% when RequestContentType::Multipart -%}, body: {{ op.name.pascal }}Request
        {%- when RequestContentType::OctetStream -%}, body: bytes::Bytes
        {%- when RequestContentType::Json -%}
        {% if let Some(body) = op.http.body -%}
        {% if let Some(variant) = body.variants.first() %}, Json(body): Json<{{ variant.ty.target|render_type }}>{% endif -%}
        {% endif -%}
        {% when RequestContentType::None -%}
        {% endmatch %}
        | async move {
            {% if op.http.path_params .len() == 1 -%}
            let {{ op.http.path_params[0].name.snake|escape_rust_keyword }} = path_params;
            {% else if op.http.path_params .len() > 1 -%}
            let ({% for p in op.http.path_params -%}
                {{ p.name.snake|escape_rust_keyword }}{% if !loop.last %}, {% endif -%}
            {% endfor %}) = path_params;
            {% endif -%}

            match service.{{ op.name.snake }}(
                ctx,
                {% for param in op.http.path_params -%}
                {{ param.name.snake|escape_rust_keyword }},
                {% endfor -%}
                {% if op.http.query .len() > 0 -%}
                query,
                {% endif -%}
                {% match op_wrap.request_content_type -%}
                {% when RequestContentType::None -%}
                {% when _ -%}
                body,
                {% endmatch -%}
            ).await {
                Ok({% if let Some(success) = op.success %}{% if success.ty.is_some() %}result{% else %}_{% endif %}{% else %}_{% endif %}) => {
                    {% if let Some(success) = op.success -%}
                    {% match success.status -%}
                    {% when ir::gen_ir::StatusSpec::Code with (code) -%}
                    let status = {{ code|status_code_const }};
                    {% when _ -%}
                    let status = StatusCode::OK;
                    {% endmatch -%}
                    {% if success.ty.is_some() -%}
                    {% match op_wrap.response_content_type -%}
                    {% when ResponseContentType::Binary -%}
                    // Binary response - use the wrapper's IntoResponse which sets Content-Type
                    (status, result).into_response()
                    {% when ResponseContentType::MultipleBinary -%}
                    // Multiple binary content types - result implements IntoResponse with proper headers
                    (status, result).into_response()
                    {% when _ -%}
                    (status, Json(result)).into_response()
                    {% endmatch -%}
                    {% else -%}
                    status.into_response()
                    {% endif -%}
                    {% else -%}
                    let status = StatusCode::OK;
                    status.into_response()
                    {% endif -%}
                }
                Err(e) => e.into_response(),
            }
        };

        {% endfor -%}
        Router::new()
            {% for op_wrap in operations -%}
            .route("{{ op_wrap.operation.http.path_template }}", {{ op_wrap.method_fn }}({{ op_wrap.operation.name.snake }}_handler))
            {% endfor -%}
            .layer(Extension(self))
    }
}

// Query parameter structs
{% for op_wrap in operations -%}
{% set op = op_wrap.operation -%}
{% if op.http.query.len() > 0 -%}
#[derive(Debug, serde::Deserialize)]
pub struct {{ op.name.pascal }}Query {
    {% for param in op.http.query -%}
    {% if param.required -%}
    pub {{ param.name.snake|escape_rust_keyword }}: String,
    {% else -%}
    pub {{ param.name.snake|escape_rust_keyword }}: Option<String>,
    {% endif -%}
    {% endfor %}
}

{% endif -%}
{% endfor %}
