//! {{ trait_name }} service module
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    routing::{
        {%- for method in methods %}{{ method }}{% if !loop.last %}, {% endif %}{% endfor -%}
    },
    Extension, Json, Router,
};

use crate::shared::RequestContext;

{% if has_bearer_auth -%}
/// Bearer authentication token
#[derive(Clone, Debug)]
pub struct AuthBearer(pub String);

{% endif -%}
{% if has_api_key_auth -%}
/// API Key authentication
#[derive(Clone, Debug)]
pub struct AuthApiKey(pub String);

{% endif -%}

// Per-operation result and error types
{% for op_wrap in operations -%}
{% set op = op_wrap.operation -%}

// {{ op.name.pascal }} types
{% if let Some(success) = op.success -%}
{% if let Some(ty) = success.ty -%}
pub type {{ op.name.pascal }}Result = Result<crate::types::{{ ty.target }}, {{ op.name.pascal }}Error>;
{% else -%}
pub type {{ op.name.pascal }}Result = Result<(), {{ op.name.pascal }}Error>;
{% endif -%}
{% else -%}
pub type {{ op.name.pascal }}Result = Result<(), {{ op.name.pascal }}Error>;
{% endif -%}

#[derive(Debug)]
pub enum {{ op.name.pascal }}Error {
    {% match op.errors -%}
    {% when ir::gen_ir::ErrorUse::Inline with (error_decl) -%}
    {% for variant in error_decl.variants -%}
    /// Status: {{ variant.status|fmt("{:?}") }}
    {{ variant.name.pascal }}{% if let Some(ty) = variant.ty %}(crate::types::{{ ty.target }}){% endif %},
    {% endfor -%}
    {% when _ -%}
    InternalError(String),
    {% endmatch -%}
}

impl IntoResponse for {{ op.name.pascal }}Error {
    fn into_response(self) -> Response {
        match self {
            {% match op.errors -%}
            {% when ir::gen_ir::ErrorUse::Inline with (error_decl) -%}
            {% for variant in error_decl.variants -%}
            {{ op.name.pascal }}Error::{{ variant.name.pascal }}{% if variant.ty.is_some() %}(err){% endif %} => {
                {% match variant.status -%}
                {% when ir::gen_ir::StatusSpec::Code with (code) -%}
                let status = {{ code|status_code_const }};
                {% when _ -%}
                let status = StatusCode::BAD_REQUEST;
                {% endmatch -%}
                {% if variant.ty.is_some() -%}
                (status, Json(err)).into_response()
                {% else -%}
                status.into_response()
                {% endif -%}
            }
            {% endfor -%}
            {% when _ -%}
            {{ op.name.pascal }}Error::InternalError(msg) => {
                (StatusCode::INTERNAL_SERVER_ERROR, msg).into_response()
            }
            {% endmatch -%}
        }
    }
}

{% endfor %}

/// {{ trait_name }} service trait
///
/// # Example
///
/// ```rust
/// use {{ package_name }}::shared::RequestContext;
/// use {{ package_name }}::services::{{ module_name }}::{
///     {{ trait_name }},
{% for op_wrap in operations -%}
{% set op = op_wrap.operation -%}
///     {{ op.name.pascal }}Result,
{% if op.http.query.len() > 0 -%}
///     {{ op.name.pascal }}Query,
{% endif -%}
{% endfor -%}
/// };
///
/// // Define your application state
/// #[derive(Clone)]
/// struct AppState {
///     // Add your state fields here (e.g., database connection, config, etc.)
/// }
///
/// // Define your service implementation
/// #[derive(Clone)]
/// struct {{ trait_name }}Service {
///     // Add any dependencies your service needs
/// }
///
/// impl {{ trait_name }}Service {
///     fn new() -> Self {
///         Self {}
///     }
/// }
///
/// // Implement the trait
/// impl {{ trait_name }}<AppState> for {{ trait_name }}Service {
{% for op_wrap in operations -%}
{% set op = op_wrap.operation -%}
///     async fn {{ op.name.snake }}(
///         &self,
///         ctx: RequestContext<AppState>,
{% for param in op.http.path_params -%}
///         {{ param.name.snake|escape_rust_keyword }}: String,
{% endfor -%}
{% if op.http.query.len() > 0 -%}
///         query: {{ op.name.pascal }}Query,
{% endif -%}
{% if let Some(body) = op.http.body -%}
{% if let Some(variant) = body.variants.first() -%}
///         body: {{ package_name }}::types::{{ variant.ty.target }},
{% endif -%}
{% endif -%}
///     ) -> {{ op.name.pascal }}Result {
///         // Implement your business logic here
{% if let Some(success) = op.success -%}
{% if let Some(ty) = success.ty -%}
///         // Return Ok(your_{{ ty.target|lower }}) or Err(error)
///         todo!("implement {{ op.name.snake }}")
{% else -%}
///         Ok(())
{% endif -%}
{% else -%}
///         Ok(())
{% endif -%}
///     }
///
{% endfor -%}
/// }
///
/// // Usage: Create router and merge into your app
/// # async fn example() {
/// let state = AppState {};
/// let service = {{ trait_name }}Service::new();
///
/// let app = axum::Router::new()
///     .with_state(state)
///     .merge(service.router());
/// # }
/// ```
pub trait {{ trait_name }}<S>: Send + Sync + Clone + Sized + 'static
where
    S: Clone + Send + Sync + 'static,
{
    {% for op_wrap in operations -%}
    {% set op = op_wrap.operation -%}
    /// {{ op.http.method|fmt("{:?}") }} {{ op.http.path_template }}
    fn {{ op.name.snake }}(
        &self,
        ctx: RequestContext<S>,
        {% for param in op.http.path_params -%}
        {{ param.name.snake|escape_rust_keyword }}: String,
        {% endfor -%}
        {% if op.http.query .len() > 0 -%}
        query: {{ op.name.pascal }}Query,
        {% endif -%}
        {% if let Some(body) = op.http.body -%}
        {% if let Some(variant) = body.variants.first() -%}
        body: crate::types::{{ variant.ty.target }},
        {% endif -%}
        {% endif -%}
    ) -> impl std::future::Future<Output = {{ op.name.pascal }}Result> + Send;

    {% endfor -%}

    /// Create a router for this service
    fn router(self) -> Router<S> {
        {% for op_wrap in operations -%}
        {% set op = op_wrap.operation -%}
        let {{ op.name.snake }}_handler = |ctx: RequestContext<S>, Extension(service): Extension<Self>{% if op.http.path_params .len() == 1 %}, axum::extract::Path(path_params): axum::extract::Path<String>{% else if op.http.path_params .len() > 1 %}, axum::extract::Path(path_params): axum::extract::Path<({% for p in op.http.path_params -%}
            String{% if !loop.last %}, {% endif -%}
        {% endfor %})>{% endif -%}
        {% if op.http.query .len() > 0 %}, axum::extract::Query(query): axum::extract::Query<{{ op.name.pascal }}Query>{% endif -%}
        {% if let Some(body) = op.http.body -%}
        {% if let Some(variant) = body.variants.first() %}, Json(body): Json<crate::types::{{ variant.ty.target }}>{% endif -%}
        {% endif -%}
        | async move {
            {% if op.http.path_params .len() == 1 -%}
            let {{ op.http.path_params[0].name.snake|escape_rust_keyword }} = path_params;
            {% else if op.http.path_params .len() > 1 -%}
            let ({% for p in op.http.path_params -%}
                {{ p.name.snake|escape_rust_keyword }}{% if !loop.last %}, {% endif -%}
            {% endfor %}) = path_params;
            {% endif -%}

            match service.{{ op.name.snake }}(
                ctx,
                {% for param in op.http.path_params -%}
                {{ param.name.snake|escape_rust_keyword }},
                {% endfor -%}
                {% if op.http.query .len() > 0 -%}
                query,
                {% endif -%}
                {% if let Some(body_type) = op.http.body -%}
                {% if body_type.variants .len() > 0 -%}
                body,
                {% endif -%}
                {% endif -%}
            ).await {
                Ok({% if let Some(success) = op.success %}{% if success.ty.is_some() %}result{% else %}_{% endif %}{% else %}_{% endif %}) => {
                    {% if let Some(success) = op.success -%}
                    {% match success.status -%}
                    {% when ir::gen_ir::StatusSpec::Code with (code) -%}
                    let status = {{ code|status_code_const }};
                    {% when _ -%}
                    let status = StatusCode::OK;
                    {% endmatch -%}
                    {% if success.ty.is_some() -%}
                    (status, Json(result)).into_response()
                    {% else -%}
                    status.into_response()
                    {% endif -%}
                    {% else -%}
                    let status = StatusCode::OK;
                    status.into_response()
                    {% endif -%}
                }
                Err(e) => e.into_response(),
            }
        };

        {% endfor -%}
        Router::new()
            {% for op_wrap in operations -%}
            .route("{{ op_wrap.operation.http.path_template }}", {{ op_wrap.method_fn }}({{ op_wrap.operation.name.snake }}_handler))
            {% endfor -%}
            .layer(Extension(self))
    }
}

// Query parameter structs
{% for op_wrap in operations -%}
{% set op = op_wrap.operation -%}
{% if op.http.query.len() > 0 -%}
#[derive(Debug, serde::Deserialize)]
pub struct {{ op.name.pascal }}Query {
    {% for param in op.http.query -%}
    {% if param.required -%}
    pub {{ param.name.snake|escape_rust_keyword }}: String,
    {% else -%}
    pub {{ param.name.snake|escape_rust_keyword }}: Option<String>,
    {% endif -%}
    {% endfor %}
}

{% endif -%}
{% endfor %}
